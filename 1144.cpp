#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define PI (acos(-1))
#define ct cout<<
#define cn cin>>
#define spc <<" "<<
#define nl puts("")
#define _fl(x) puts("FLAG " #x),fflush(stdout);
#define  _(x)  cout<< #x <<" is "<< x <<endl;
#define fs first
#define sc second
#define pb push_back
#define all(v)  (v).begin(), (v).end()
#define _109 (1000000000)
#define _0(arr) memset(arr,0,sizeof ( arr ) )
#define _1(arr) memset(arr,-1,sizeof ( arr ) )
#define _ninp(n,arr) for(int i=0; i<n;i++)cin>>arr[i];
#define _nout(n,arr) for(int i=0; i<n;i++)cout<<arr[i]<<" \n"[i==n-1];
double _eps=1e-6;


/***
  *  the lines are in ax=by from
     and y=(a/b)x

  *  question is how many different slopes are there.
     Or 1<=a <=N and 1<=b<= M and a/b is unique. Let N<=10^6 

  *  if a and b are coprime a/b will be unique
     so the question is how many pairs (a,b) are there for 1<=a <=N and 1<=b<= M
     such that a,b are coprime
    
  *  For a fixed "a" we have to count how many numbers from range 1 to M are 
     coprime with "a"

     or M - (numbers not coprime with "a") 
     we can prime factorize "a" and use exclusion-inclusion to count numbers
     not coprime with a

     a=6, M=10 

     (not coprimes)= (numbers multiple of 3) + (numbers multiple of 2) - (numbers multiple of both 2 and 3)
                   = 10/3 + 10/2 - 10/6
                   = 3+5+1=7
     coprimes=10-7=3

     notice that for a=4 we cant take 2 and 2 and apply inclusion-exlusion with two 2s like that,
     it will produce wrong count, we have to take account only one 2 here

     finally we can do this for every number "a" from range 1 to N and add the result;
     but it is slow, wont work.


  *  when we were using exlusion-inclusion we were just producing a number ,say x,
     that is factor of "a".

     when we iterate the process for every "a" in range 1 to N we may produce that x agian
     and add or subtract (depending on the number of primes it is generated by)
     M/x to the result;

     so how many times we produce that x.

     As there are N/x multiples of x, x will be produced N/x times.

     So every Number in 1 to N will be produced int the process except
     the numbers that has same prime factors more than twice (notice in previous section for a=4,
     x=4 will not be produced as we wont take 2 twice in any case)


*/

const int size=1000000;
int  primeCount[size+10];
bool notProduced[size+10];

int main() {

    for (int i = 2; i <=size; ++i)
        {
        	if(primeCount[i])continue;
        	for(int j=i; j<=size ; j+=i)primeCount[j]++;
        } 

    for (int i = 2; i <=1000 ; ++i)
        for(int j=i*i; j<=size ; j+=i*i)notProduced[j]=true;


     int T;
        cn T;
    for(int caseno=1; caseno<=T  ;caseno++){
    
    ll n,m;
    cn n>>m;

    if(n>m)swap(n,m);
    
    ll ans=(n-1)*m;  
    if(n==0 && m)ans=1;
    else if(n+m==0)ans=0;
    else{

       for (int x = 2; x <=n ; ++x)
       {  
       	  if (notProduced[x])continue;

       	  if(primeCount[x]&1)ans-=(m/x)*(n/x);
       	  else ans+=(m/x)*(n/x);
       }

       ans+=m; // for x=1 how many numbers 1 is coprime with
       ans+=2; // extra two side line
    }
    
    printf("Case %d: %lld\n",caseno,ans);
    }




    return 0;
}
